using System;
using System.Linq;
using Autofac;
using Autofac.Extensions.DependencyInjection;
using Battleship.Domain.CommandHandlers;
using Battleship.Domain.Commands;
using Battleship.Domain.CQRS;
using Battleship.Domain.CQRS.Events;
using Battleship.Domain.CQRS.Events.Storage;
using Battleship.Domain.CQRS.Persistence;
using Battleship.Domain.CQRS.Utilities;
using Battleship.Domain.EventHandlers;
using Battleship.Domain.Events;
using Battleship.Domain.Persistence;
using Battleship.Domain.ReadModel;
using Battleship.Domain.ReadModel.Enums;
using Microsoft.Extensions.DependencyInjection;

namespace Battleship.Application
{
    internal class Program
    {
        private static AutofacServiceProvider _services;
        private static ICommandSender _commandBus;
        private static IReadModelFacade _read;
        private static GameDetails _currentGame;

        // ReSharper disable once UnusedParameter.Local
        private static void Main(string[] args)
        {
            ApplicationSetup();

            bool keepPlaying;
            do
            {
                Console.Clear();
                CreateNewGame();
                GetPlayerNames();
                AddShips();

                do
                {
                    PerformAttack();
                    _currentGame = _read.Get<GameDetails>(_currentGame.Id);
                    WriteLabel("Showing opponents board for demonstration of progress in game.");
                    var targetPlayerIndex = _currentGame.Turn % 2;
                    DrawPlayersBoard(_currentGame.Players[targetPlayerIndex].Board.Representation);
                    WriteLabel(_currentGame.Players[targetPlayerIndex].Board.LastAttackMessage);
                    WriteLine();
                } while (_currentGame.HasWinner == null);

                keepPlaying = WouldYouLikeToKeepPlaying();
            } while (keepPlaying);

            Console.Clear();
            WriteDefault("Events generated by the most recent game.");
            ShowGameEvents();
            WriteLine();
            Console.Write("Press <enter> to end.");
            Console.ReadLine();
        }

        private static void PerformAttack()
        {
            // playerIndex is the modulus of the turn
            var attackingPlayerIndex = _currentGame.Turn % 2;
            var targetPlayer = (uint) (attackingPlayerIndex == 0 ? 1 : 0);

            var row = GetRowForPlayer(attackingPlayerIndex);
            var col = GetColForPlayer(attackingPlayerIndex);
            _commandBus.Send(new FireShot(Guid.NewGuid(), _currentGame.Version, _currentGame.Id, new Location(row, col), attackingPlayerIndex, targetPlayer));
        }

        private static void AddShips()
        {
            for (uint playerIndex = 0; playerIndex < 2; playerIndex++)
            {
                ShipDetails shipToAdd = null;
                var needToPlaceShip = true;
                do
                {
                    WriteInstruction("You are about to place a Destroyer (3 spaces) on your board. We will pick a spot on the board to place the bow (front)");
                    WriteInstruction("and then we will pick the direction that your boat is heading.");
                    var row = GetRowValue(playerIndex, "Please enter the row for the bow of your ship");
                    var col = GetColumnValue(playerIndex, "Please enter the column for the bow of your ship");
                    var heading = GetHeadingValue(playerIndex);
                    var location = new Location(row, col);

                    // See if user inputs are valid
                    if (!_currentGame.IsValidLocation(location, playerIndex)) { continue; }

                    shipToAdd = new ShipDetails
                    {
                        BowAt = location,
                        Heading = ConvertToHeading(heading),
                        ClassSize = 3,
                        ClassName = "Destroyer",
                        Status = ShipStatus.Active
                    };
                    // see if ship can be placed here
                    needToPlaceShip = !_currentGame.IsValidShipLocation(shipToAdd, playerIndex);
                } while (needToPlaceShip);

                // send command to add the ship
                var newCommandId = Guid.NewGuid();
                _commandBus.Send(new AddShip(newCommandId, _currentGame.Version, _currentGame.Id, playerIndex, shipToAdd));

                // refresh current view of the game
                _currentGame = _read.Get<GameDetails>(_currentGame.Id);
                DrawPlayersBoard(_currentGame.Players[playerIndex].Board.Representation);
            }
        }

        private static void DrawPlayersBoard(char[,] boardRepresentation)
        {
            for (var i = 0; i <= _currentGame.Dimensions; i++)
            {
                for (var j = 0; j <= _currentGame.Dimensions; j++)
                {
                    Console.Write(boardRepresentation[i,j]);
                }
                WriteLine();
            }
            WriteLine();
        }

        private static uint GetColumnValue(uint playerIndex, string instruction)
        {
            uint col;
            var needToSelect = true;
            do
            {
                WriteLine();
                WriteInstruction($"{_currentGame.Players[playerIndex].Name} - {instruction}:");
                var keyPressed = Console.ReadKey().KeyChar.ToString();
                if (uint.TryParse(keyPressed, out col) && _currentGame.ValidColumnSelection(col))
                {
                    needToSelect = false;
                }
                else
                {
                    WriteLine();
                    WriteInstruction($"{_currentGame.Players[playerIndex].Name} - {col} is not a valid column value. {instruction}:");
                }
            } while (needToSelect);
            WriteLine();
            return col;
        }

        private static char GetRowValue(uint playerIndex, string instruction)
        {
            char row;
            var needToSelect = true;
            do
            {
                WriteLine();
                WriteInstruction($"{_currentGame.Players[playerIndex].Name} - {instruction}:");
                row = Console.ReadKey().KeyChar;
                if (_currentGame.ValidRowSelection(row))
                {
                    needToSelect = false;
                }
                else
                {
                    WriteLine();
                    WriteInstruction($"{_currentGame.Players[playerIndex].Name} - {row} is not a valid row value. {instruction}:");
                }
            } while (needToSelect);
            return row;
        }

        private static char GetHeadingValue(uint playerIndex)
        {
            char heading;
            var needToSelect = true;
            do
            {
                WriteInstruction($"{_currentGame.Players[playerIndex].Name} - Please enter the direction that your ship is heading:");
                WriteInstruction("Your heading options are N, E, W, S.");
                heading = Console.ReadKey().KeyChar;
                if (IsValidHeading(heading))
                {
                    needToSelect = false;
                }
                else
                {
                    WriteLine();
                    WriteInstruction($"{_currentGame.Players[playerIndex].Name} - {heading} is not a valid heading value. Please enter the direction that your ship is heading:");
                }
                WriteLine();
            } while (needToSelect);
            return heading;
        }

        private static Direction ConvertToHeading(char heading)
        {
            switch (char.ToUpper(heading))
            {
                case 'N': return Direction.N;
                case 'E': return Direction.E;
                case 'W': return Direction.W;
                case 'S': return Direction.S;
                default:
                    throw new ArgumentException($"You cannot convert {heading} into a Direction enumeration.", nameof(heading));
            }
        }

        private static bool IsValidHeading(char heading)
        {
            var valid = new[] {'N', 'E', 'W', 'S'};
            return valid.Contains(Char.ToUpper(heading));
        }

        private static uint GetColForPlayer(uint playerIndex)
        {
            return GetColumnValue(playerIndex, "Please enter the column for your attack.");
        }

        private static char GetRowForPlayer(uint playerIndex)
        {
            return GetRowValue(playerIndex, "Please enter the row for your attack.");
        }

        private static void ShowGameEvents()
        {
            var eventStore = _services.GetRequiredService<IEventStore>();
            var gameEvents = eventStore.GetEventsForAggregate(_currentGame.Id);
            foreach (var e in gameEvents)
                WriteFinishColor($"Type: {e.GetType().Name} - Version: {e.Version} - EventId: {e.Id}");
        }

        private static bool WouldYouLikeToKeepPlaying()
        {
            WriteInstruction("Would you like to play again? (Y/N)");
            var key = Console.ReadKey();
            return key.Key == ConsoleKey.Y;
        }

        private static void GetPlayerNames()
        {
            var playerNames = new string[2];
            for (var i = 0; i < playerNames.Length; i++)
            {
                do
                {
                    WriteInstruction($"Please enter the name for Player #{i}:");
                    playerNames[i] = Console.ReadLine();
                } while (string.IsNullOrEmpty(playerNames[i]));
                var newCommandId = Guid.NewGuid();
                _commandBus.Send(new UpdatePlayerName(newCommandId, _currentGame.Version, _currentGame.Id,
                    playerNames[i], i));
                _currentGame = _read.Get<GameDetails>(_currentGame.Id);
            }
        }

        private static void CreateNewGame()
        {
            WriteInstruction(
                $"Welcome to Battleship. We are creating a new game for you.{Environment.NewLine}{Environment.NewLine}");
            var newGameGuid = Guid.NewGuid();
            _commandBus.Send(new CreateGame(newGameGuid, 8) {ReceivedOn = DateTime.UtcNow});
            _currentGame = _read.Get<GameDetails>(newGameGuid);
            WriteLabel($"GameId: {_currentGame.Id}");
            WriteLabel($"Dimensions: {_currentGame.Dimensions}x{_currentGame.Dimensions}");
            WriteLabel($"CreatedOn: {_currentGame.ActivatedOn} UTC");
            WriteLine();
        }

        private static void ApplicationSetup()
        {
            // Autofac
            var builder = new ContainerBuilder();
            builder.RegisterModule(new AutofacModule());

            // ReadModel Persistence
            builder.RegisterType<InMemoryReadModelStorage>()
                .As<IReadModelFacade>()
                .As<IReadModelPersistence>()
                .SingleInstance();

            // Agggregate Command/Event Persistence
            builder.RegisterType<AggregateRepository>().As<IAggregateRepository>().SingleInstance();
            builder.RegisterType<InMemoryCommandRepository>().As<ICommandRepository>().SingleInstance();
            builder.RegisterType<InMemoryEventDescriptorStorage>().As<IEventDescriptorStorage>().SingleInstance();
            builder.RegisterType<EventStore>().As<IEventStore>().SingleInstance();

            // Command/Event Handling
            builder.RegisterType<CommandHandlerFactory>().As<ICommandHandlerFactory>().SingleInstance();
            builder.RegisterType<EventHandlerFactory>().As<IEventHandlerFactory>().SingleInstance();

            // MessageBus (shared)
            builder.RegisterType<MessageBus>()
                .As<ICommandSender>()
                .As<IEventPublisher>()
                .SingleInstance();

            _services = new AutofacServiceProvider(builder.Build());

            _commandBus = _services.GetRequiredService<ICommandSender>();
            _read = _services.GetRequiredService<IReadModelFacade>();
        }

        #region UI Helpers

        private static void WriteLine()
        {
            Console.WriteLine();
        }

        private static void WriteDefault(string s)
        {
            ResetConsoleColors();
            Console.WriteLine(s);
        }

        private static void WriteInstruction(string s)
        {
            SetInstructionColors();
            Console.WriteLine(s);
            ResetConsoleColors();
        }

        private static void WriteLabel(string s)
        {
            SetLabelColors();
            Console.WriteLine(s);
            ResetConsoleColors();
        }

        private static void WriteFinishColor(string s)
        {
            SetFinishedColors();
            Console.WriteLine(s);
            ResetConsoleColors();
        }

        private static void ResetConsoleColors()
        {
            Console.ResetColor();
        }

        private static void SetLabelColors()
        {
            Console.BackgroundColor = ConsoleColor.Blue;
            Console.ForegroundColor = ConsoleColor.White;
        }

        private static void SetFinishedColors()
        {
            Console.BackgroundColor = ConsoleColor.Green;
            Console.ForegroundColor = ConsoleColor.DarkBlue;
        }

        private static void SetInstructionColors()
        {
            Console.BackgroundColor = ConsoleColor.Black;
            Console.ForegroundColor = ConsoleColor.Yellow;
        }

        #endregion
    }
}