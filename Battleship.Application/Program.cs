using Autofac;
using Autofac.Extensions.DependencyInjection;
using Battleship.Application.Modules;
using Battleship.Domain;
using Battleship.Domain.Aggregates.Game;
using Battleship.Domain.Commands;
using Battleship.Domain.Core.Messaging;
using Battleship.Domain.Core.Services.Messaging;
using Battleship.Domain.Core.Services.Persistence;
using Battleship.Domain.Core.Services.Persistence.CQRS;
using Battleship.Domain.Core.Services.Persistence.EventSource;
using Battleship.Domain.Core.Services.Persistence.EventSource.Aggregates;
using Battleship.Domain.Entities;
using Battleship.Domain.Enums;
using Battleship.Domain.Projections;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using NodaTime;
using Serilog.Events;
using Serilog;

namespace Battleship.Application
{
    public static class HostBuilderExtensions
    {
        public static IHostBuilder LoadAutofacModules(this IHostBuilder builder, DefaultOwnershipContextResolver? ownershipResolver)
        {
            builder.ConfigureContainer<ContainerBuilder>(b => b.RegisterModule(new LoggingModule()))
                .ConfigureContainer<ContainerBuilder>(b => b.RegisterModule(new ApplicationModule(ownershipResolver)))
                .ConfigureContainer<ContainerBuilder>(b => b.RegisterModule(new MediatRModule()));

            return builder;
        }
    }

    internal class Program
    {
        private static ICommandSender _commandBus;
        private static IReadModelQuery _read;
        private static IAggregateRepository<Game> _gameRepo;
        private static IClock _clock;
        private static IEventStore<Game> _eventStore;

        private static async Task Main(string[] args)
        {
            var host = Host.CreateDefaultBuilder(args)
                .UseSerilog(ConfigureLogging)
                .UseServiceProviderFactory(new AutofacServiceProviderFactory())
                .LoadAutofacModules(new DefaultOwnershipContextResolver(Guid.Empty))
                .Build();

            using (host)
            {
                await host.StartAsync();

                _commandBus = host.Services.GetRequiredService<ICommandSender>();
                _read = host.Services.GetRequiredService<IReadModelQuery>();
                _gameRepo = host.Services.GetRequiredService<IAggregateRepository<Game>>();
                _clock = host.Services.GetRequiredService<IClock>();
                _eventStore = host.Services.GetRequiredService<IEventStore<Game>>();

                await MainLoop(args);
            }
        }

        // ReSharper disable once UnusedParameter.Local
        private static async Task MainLoop(string[] args)
        {
            var gameId = Guid.NewGuid();

            bool keepPlaying;
            do
            {
                Console.Clear();
                await CreateNewGame(gameId);
                await GetPlayerNames(gameId);
                await AddShips(gameId);
                var hasWinner = false;
                do
                {
                    await PerformAttack(gameId);
                    var currentGame = await _read.GetItemAsync<GameProjection>(Guid.Empty, gameId.ToString());
                    if (currentGame != null)
                    {
                        if (currentGame.Winner != null) hasWinner = true;

                        WriteLabel("Showing opponents board for demonstration of progress in game.");
                        var targetPlayerIndex = (uint)currentGame.Turn % 2;
                        await DrawPlayersBoard(targetPlayerIndex, gameId);
                        WriteLabel(currentGame.LastMessage);
                        WriteLine();
                    }
                    else
                    {
                        throw new Exception("The game broke. Sorry!");
                    }
                } while (!hasWinner);
                keepPlaying = WouldYouLikeToKeepPlaying();
            } while (keepPlaying);

            Console.Clear();
            WriteDefault("Events generated by the most recent game.");
            ShowGameEvents(gameId);
            WriteLine();
            Console.Write("Press <enter> to end.");
            Console.ReadLine();
        }

        private static async Task PerformAttack(Guid gameId)
        {
            var currentGame= await _gameRepo.GetAsync(gameId.ToString());
            // playerIndex is the modulus of the turn
            var attackingPlayerIndex = (uint) currentGame.Turn % 2;
            var targetPlayer = (uint) (attackingPlayerIndex == 0 ? 1 : 0);

            var row = GetRowForPlayer(attackingPlayerIndex, gameId);
            var col = GetColForPlayer(attackingPlayerIndex, gameId);
            await _commandBus.SendAsync(new FireShot(attackingPlayerIndex, targetPlayer, new Location(row, col), 
                new AggregateParams(currentGame.AggregateId, currentGame.Version, false, Guid.Empty), 
                new EventParams("", _clock.GetCurrentInstant(), "", Guid.Empty)));
        }

        private static async Task AddShips(Guid gameId)
        {
            var game = await _gameRepo.GetAsync(gameId.ToString());
            for (uint playerIndex = 0; playerIndex < 2; playerIndex++)
            {
                Ship shipToAdd;
                var needToPlaceShip = true;
                do
                {
                    WriteInstruction(
                        "You are about to place a Cruiser (3 spaces) on your board. We will pick a spot on the board to place the bow (front)");
                    WriteInstruction("and then we will pick the direction that your boat is heading.");
                    var row = await GetRowValue(playerIndex, "Please enter the row for the bow of your ship", gameId);
                    var col = await GetColumnValue(playerIndex, "Please enter the column for the bow of your ship", gameId);
                    var heading = await GetHeadingValue(playerIndex, gameId);
                    var location = new Location(row, col);

                    shipToAdd = ShipFactory.BuildShip(ShipType.Cruiser, location, ConvertToHeading(heading));

                    // see if ship can be placed here
                    var (added, message) = game.AddShip(shipToAdd, playerIndex, new EventParams("", _clock.GetCurrentInstant(), "", Guid.Empty));
                    if (!added)
                    {
                        WriteInstruction(message);
                    }
                    else
                    {
                        needToPlaceShip = false;
                    }
                } while (needToPlaceShip);

                // send command to add the ship
                await _commandBus.SendAsync(new AddShip(playerIndex, shipToAdd, 
                    new AggregateParams(gameId.ToString(), -1, false, Guid.Empty), 
                    new EventParams("", _clock.GetCurrentInstant(), "", Guid.Empty)));

                // refresh current view of the game
                await DrawPlayersBoard(playerIndex, gameId);
            }
        }

        private static async Task DrawPlayersBoard(uint playerIndex, Guid gameId)
        {
            var currentGame = await GetGameProjection(gameId);
            var boardRepresentation = currentGame.Players[playerIndex].Board.Representation;
            for (var i = 0; i <= currentGame.Dimensions; i++)
            {
                for (var j = 0; j <= currentGame.Dimensions; j++)
                    Console.Write(boardRepresentation[i, j]);
                WriteLine();
            }
            WriteLine();
        }

        private static async Task<uint> GetColumnValue(uint playerIndex, string instruction, Guid gameId)
        {
            uint col;
            var needToSelect = true;
            var currentGame = await GetGameProjection(gameId);
            do
            {
                WriteLine();
                WriteInstruction($"{currentGame.Players[playerIndex].Name} - {instruction}:");
                var keyPressed = Console.ReadKey().KeyChar.ToString();
                if (uint.TryParse(keyPressed, out col) && currentGame.ValidColumnSelection(col))
                {
                    needToSelect = false;
                }
                else
                {
                    WriteLine();
                    WriteInstruction(
                        $"{currentGame.Players[playerIndex].Name} - {col} is not a valid column value. {instruction}:");
                }
            } while (needToSelect);
            WriteLine();
            return col;
        }

        private static async Task<char> GetRowValue(uint playerIndex, string instruction, Guid gameId)
        {
            char row;
            var needToSelect = true;
            var currentGame = await GetGameProjection(gameId);
            do
            {
                WriteLine();
                WriteInstruction($"{currentGame.Players[playerIndex].Name} - {instruction}:");
                row = Console.ReadKey().KeyChar;
                if (currentGame.ValidRowSelection(row))
                {
                    needToSelect = false;
                }
                else
                {
                    WriteLine();
                    WriteInstruction(
                        $"{currentGame.Players[playerIndex].Name} - {row} is not a valid row value. {instruction}:");
                }
            } while (needToSelect);
            return row;
        }

        private static async Task<char> GetHeadingValue(uint playerIndex, Guid gameId)
        {
            var currentGame = await GetGameProjection(gameId);
            char heading;
            var needToSelect = true;
            do
            {
                WriteInstruction(
                    $"{currentGame.Players[playerIndex].Name} - Please enter the direction that your ship is heading:");
                WriteInstruction("Your heading options are N, E, W, S.");
                heading = Console.ReadKey().KeyChar;
                if (IsValidHeading(heading))
                {
                    needToSelect = false;
                }
                else
                {
                    WriteLine();
                    WriteInstruction(
                        $"{currentGame.Players[playerIndex].Name} - {heading} is not a valid heading value. Please enter the direction that your ship is heading:");
                }
                WriteLine();
            } while (needToSelect);
            return heading;
        }

        private static Heading ConvertToHeading(char heading)
        {
            return char.ToUpper(heading) switch
            {
                'N' => Heading.N,
                'E' => Heading.E,
                'W' => Heading.W,
                'S' => Heading.S,
                _ => throw new ArgumentException($"You cannot convert {heading} into a Heading enumeration.",
                    nameof(heading))
            };
        }

        private static bool IsValidHeading(char heading)
        {
            var valid = new[] {'N', 'E', 'W', 'S'};
            return valid.Contains(char.ToUpper(heading));
        }

        private static uint GetColForPlayer(uint playerIndex, Guid gameId)
        {
            return GetColumnValue(playerIndex, "Please enter the column for your attack.", gameId).GetAwaiter().GetResult();
        }

        private static char GetRowForPlayer(uint playerIndex, Guid gameId)
        {
            return GetRowValue(playerIndex, "Please enter the row for your attack.", gameId).GetAwaiter().GetResult();
        }

        private static void ShowGameEvents(Guid gameId)
        {
            var gameEvents = _eventStore.GetEventsForAggregateAsync(gameId.ToString()).Result;
            foreach (var e in gameEvents)
                WriteFinishColor($"AggregateId: {gameId} Event Type: {e.GetType().Name} - Aggregate Version: {e.AggParams.Version} - EventId: {e.MessageId}");
        }

        private static bool WouldYouLikeToKeepPlaying()
        {
            WriteInstruction("Would you like to play again? (Y/N)");
            var key = Console.ReadKey();
            return key.Key == ConsoleKey.Y;
        }

        private static async Task GetPlayerNames(Guid gameId)
        {
            var game = await GetGameAggregate(gameId);
            var playerNames = new string[2];
            for (uint i = 0; i < playerNames.Length; i++)
            {
                do
                {
                    WriteInstruction($"Please enter the name for Player #{i}:");
                    playerNames[i] = Console.ReadLine();
                } while (string.IsNullOrEmpty(playerNames[i]));
                await _commandBus.SendAsync(new UpdatePlayerName(playerNames[i], i,
                    new AggregateParams(game.AggregateId, game.Version,false, Guid.Empty), 
                    new EventParams("", _clock.GetCurrentInstant(), "", Guid.Empty)));
            }
        }

        private static async Task CreateNewGame(Guid gameId)
        {
            WriteInstruction(
                $"Welcome to Battleship. We are creating a new game for you.{Environment.NewLine}{Environment.NewLine}");
            
            await _commandBus.SendAsync(new CreateGame(8, 
                new AggregateParams(gameId.ToString(), -1, false, Guid.Empty), 
                new EventParams("", _clock.GetCurrentInstant(), "", Guid.Empty)));
            var currentGame = await _read.GetItemAsync<GameProjection>(Guid.Empty, gameId.ToString());
            WriteLabel($"GameId: {currentGame.AggregateId}");
            WriteLabel($"Dimensions: {currentGame.Dimensions}x{currentGame.Dimensions}");
            WriteLabel($"CreatedOn: {currentGame.ActivatedOn} UTC");
            WriteLine();
        }

        private static async Task<Game> GetGameAggregate(Guid id)
        {
            return await _gameRepo.GetAsync(id.ToString());
        }

        private static async Task<GameProjection> GetGameProjection(Guid id)
        {
            return await _read.GetItemAsync<GameProjection>(Guid.Empty, id.ToString());
        }

        #region UI Helpers

        private static void WriteLine()
        {
            Console.WriteLine();
        }

        private static void WriteDefault(string s)
        {
            ResetConsoleColors();
            Console.WriteLine(s);
        }

        private static void WriteInstruction(string s)
        {
            SetInstructionColors();
            Console.WriteLine(s);
            ResetConsoleColors();
        }

        private static void WriteLabel(string s)
        {
            SetLabelColors();
            Console.WriteLine(s);
            ResetConsoleColors();
        }

        private static void WriteFinishColor(string s)
        {
            SetFinishedColors();
            Console.WriteLine(s);
            ResetConsoleColors();
        }

        private static void ResetConsoleColors()
        {
            Console.ResetColor();
        }

        private static void SetLabelColors()
        {
            Console.BackgroundColor = ConsoleColor.Blue;
            Console.ForegroundColor = ConsoleColor.White;
        }

        private static void SetFinishedColors()
        {
            Console.BackgroundColor = ConsoleColor.Green;
            Console.ForegroundColor = ConsoleColor.DarkBlue;
        }

        private static void SetInstructionColors()
        {
            Console.BackgroundColor = ConsoleColor.Black;
            Console.ForegroundColor = ConsoleColor.Yellow;
        }

        #endregion

        private static void ConfigureLogging(HostBuilderContext ctx, LoggerConfiguration lc)
        {
            string[] lines = { "DefaultBuildNumber", "DefaultBuildId", "DefaultGitHsh" };
            try
            {
                // read the .buildinfo.json file to get build variables
                lines = File.ReadAllLinesAsync(".buildinfo.json")
                    .GetAwaiter()
                    .GetResult().First().Split(":");
            }
            catch
            {
                // don't fail if missing
                lines = new[] { "No Build Info", "1", "1" };
            }

            lc.MinimumLevel.Override("Microsoft.AspNetCore.Hosting.Diagnostics", LogEventLevel.Warning)
                .MinimumLevel.Override("Microsoft.AspNetCore.StaticFiles.StaticFileMiddleware", LogEventLevel.Warning)
                .MinimumLevel.Override("Microsoft.AspNetCore.HostFiltering.HostFilteringMiddleware",
                    LogEventLevel.Warning)
                .MinimumLevel.Override("Microsoft.AspNetCore.Server.Kestrel", LogEventLevel.Warning)
                .MinimumLevel.Override("Microsoft.AspNetCore.Routing.EndpointMiddleware", LogEventLevel.Warning)
                .MinimumLevel.Override("Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware", LogEventLevel.Warning)
                .MinimumLevel.Override("Microsoft.AspNetCore.Routing.Matching.DfaMatcher", LogEventLevel.Warning)
                .MinimumLevel.Verbose()
                .Enrich.FromLogContext()
                //.Enrich.WithMachineName()
                .Enrich.WithProperty("Environment", "Dev")
                .Enrich.WithProperty("Application", "KMM.Assessment.ConsoleApp")
                .Enrich.WithProperty("BuildNumber", lines[0])
                .WriteTo.Console(LogEventLevel.Debug, "{NewLine}{@Timestamp:HH:mm:ss} [{Level}] {Message}{Exception}");
            //.WriteTo.Seq(ctx.Configuration.GetSection("Seq:Url").Value ?? "http://localhost:5341");
        }
    }
}